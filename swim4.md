## 4. A More Robust and Efficient SWIM

## 4. 보다 견고하고 효율적인 SWIM

Section 3 described the basic SWIM protocol that disseminates membership updates (resulting from member joins, leaves or failures) using network multicast. However, network multicast primitives such as IP multicast etc., are only best-effort - message losses within the network can cause arbitrary and correlated non-receipt of membership changes at any group member. In Section 4.1, we describe the design of a Dissemination Component that piggybacks membership updates on the ping and ack messages sent by the failure detector protocol. This completely eliminates the generation of extra packets by the Dissemination Component (viz., multicasts). The only packets generated by SWIM then are pings, ping-reqs and acks, thus giving a constant expected message overhead per group member. This approach results in an infection-style of dissemination, with the associated benefits of robustness to packet losses, and of low latency.

3 장에서는 네트워크 멀티 캐스트를 사용하여 멤버십 업데이트 (멤버 가입, 탈퇴 또는 실패로 인한)를 배포하는 기본 SWIM 프로토콜에 대해 설명했습니다. 그러나 IP 멀티 캐스트 등과 같은 네트워크 멀티 캐스트 프리미티브는 최선의 노력(역주: best-effort; 무결성 보장이 되지 않는 최선의 노력을 의미함)일 뿐입니다. 네트워크 내에서 메시지 손실이 발생하면 임의의 그룹 구성원에서 멤버십 변경 정보의 누락이 발생할 수 있습니다. 4.1 절에서는 장애 감지기 프로토콜에 의해 전송된 Ping 및 ack 메시지에 대한 구성원 업데이트를 피기백(역주: piggyback; 요청에 대한 응답을 즉시 하지 않고 전달할 메시지가 있을 때 하는 방식)하는 전파기 설계에 대해 설명합니다. 이렇게하면 전파기(즉, 멀티 캐스트)에 의한 추가 패킷 생성이 완전히 제거됩니다. SWIM에 의해 생성 된 유일한 패킷은 핑, 핑-요구 및 acks이며, 따라서 그룹 구성원마다 일정한 예상 메시지 오버 헤드를 제공합니다. 이러한 접근 방식은 패킷 손실에 대한 견고성 및 낮은 대기 시간으로 인한 감염 스타일의 확산을 유도합니다.

The basic SWIM failure detector protocol, in spite of its calculable accuracy, is subject to slow processes (e.g. ones losing a lot of packets from buffer overflow) declaring several other non-faulty processes as faulty. It is also possible that a process is perturbed for small durations of time, e.g. on an overloaded host. This might cause the process to miss the opportunity to send timely replies to pings received meanwhile, and be mistakenly declared as failed. Section 4.2 presents the Suspicion mechanism, where a process that is unresponsive to ping messages, as generated by the SWIM failure detector protocol described in Section 3, is not immediately declared as “faulty”. Instead, the process is declared as “suspected”, and this information spread through the group using the Dissemination Component. After a prespecified time-out (we discuss values for this parameter in Section 5), the suspected process is declared as “faulty” and this information disseminated to the group. However, if the suspected process responds to a ping request before this time-out expires, information about this is disseminated to the group as an “alive” message. The process is then rejuvenated in membership lists at different members without ever having to leave or rejoin the group. This prespecified time-out thus effectively trades off an increase in failure detection time for a reduction in frequency of false failure detections.

기본적인 SWIM 장애 감지기 프로토콜은 계산 가능한 정확도에도 불구하고 느린 프로세스(예: 버퍼 오버플로우로 인해 많은 패킷이 손실되는 프로세스)에 따라 결함이없는 다른 여러 프로세스를 선언합니다. 프로세스가 짧은 시간 동안 교란 될 수도 있습니다(예 : 오버로드 된 호스트). 이로 인해 프로세스가 ping에 적기에 응답을 보낼 기회를 놓칠 수 있습니다. 그래서 그 동안 장애로 잘못 선언될 수 있습니다. 4.2 절은 3 장에서 설명한 SWIM 장애 탐지 프로토콜에 의해 생성 된 핑 메시지에 응답하지 않는 프로세스가 즉시 “결함”으로 선언되지 않는 의심 메커니즘을 제시합니다. 대신 프로세스가 "의심되는"것으로 선언되고 이 정보는 전파기를 사용하여 그룹을 통해 확산됩니다. 사전에 지정된 타임아웃 후(5 장에서 이런 파라미터 값들을 다룰 것입니다), 의심되는 프로세스는 "결함"으로 선언되며 이 정보는 그룹에 전파됩니다. 그러나 이 시간 제한이 만료되기 전에 의심되는 프로세스가 ping 요청에 응답하면 이에 대한 정보가 "생존" 메시지로 그룹에 배포됩니다. 그런 다음 그룹을 탈퇴하거나 다시 가입 할 필요없이 다른 회원의 회원 목록에서 프로세스가 다시 활기를 띠게됩니다. 이 사전 지정된 타임아웃 시간은 장애 감시 시간 증가와 오탐 빈도 축소 사이에서 효과적으로 절충합니다.

The basic SWIM failure detection protocol guarantees eventual detection of the failure of an arbitrary process Mi, at each non-faulty group member Mj. However, it gives no deterministic guarantees on the time between failure of an arbitrary member Mi and its detection at another arbitrary member Mj (in terms of the number of local protocol rounds at Mj). Section 4.3 describes a modification to the original SWIM failure detector protocol that guarantees such a Time Bounded Completeness property; the time interval between the occurrence of a failure and its detection at member Mj is no more than two times the group size (in number of protocol periods).

기본 SWIM 장애 감지 프로토콜은 결함이없는 각 그룹 구성원 Mj에서 임의 프로세스 Mi의 장애를 최종적으로 감지합니다. 그러나 임의의 멤버 Mi의 실패와 다른 임의의 멤버 Mj에서의 감지 사이의 시간(Mj의 로컬 프로토콜 라운드 수의 관점에서)에 대해서는 결정적인 보장을 제공하지 않습니다. 4.3 절은 그러한 시간 제한 완료 특성을 보장하는 최초의 SWIM 장애 감지기 프로토콜에 대한 수정을 기술하고 있습니다. 실패 발생과 구성원 Mj에서의 탐지 사이의 시간 간격은 그룹 크기의 두 배 (프로토콜 기간 수)입니다.


### 4.1. Infection-Style Dissemination Component

### 4.1. 감염 스타일 전파기

The basic SWIM protocol of Section 3 propagates membership updates through the group using a multicast primitive. Hardware multicast and IP multicast are available on most networks and operating systems, but are rarely enabled, e.g., for administrative reasons. The basic SWIM protocol would then have to use a costly broadcast, or an inefficient point-to-point messaging scheme, in order to disseminate the membership updates to all group members. Furthermore, as this multicast is unreliable, membership changes can be disseminated only on a best-effort basis to the group.

3 장의 기본 SWIM 프로토콜은 멀티 캐스트 프리미티브를 사용하여 그룹을 통해 멤버십 업데이트를 전파합니다. 하드웨어 멀티 캐스트 및 IP 멀티 캐스트는 대부분의 네트워크 및 운영 체제에서 사용할 수 있지만 관리상의 이유로 거의 활성화되지 않습니다. 그러면 기본 SWIM 프로토콜은 모든 그룹 구성원에게 구성원 자격 업데이트를 배포하기 위해 비용이 많이 드는 브로드캐스트 또는 비효율적인 지점 간 메시징 체계를 사용해야합니다. 또한 이 멀티 캐스트는 신뢰할 수 없으므로 멤버십 변경은 그룹에 최선의 노력(best-effort)으로 만 전파될 수 있습니다.

Instead, the augmented SWIM protocol eliminates the use of an external multicast primitive altogether. It does so by piggybacking the information to be disseminated on the ping, ping-req and ack messages generated by the failure detector protocol. We call this an infection-style dissemination mechanism as information spreads in a manner analogous to the spread of gossip in society, or epidemic in the general population [8]. Notice that this implementation of the Dissemination Component does not generate any extra packets (such as multicasts) - all “messages” handed to this component are propagated by piggybacking on the packets of the Failure Detection Component.

대신, 확장 된 SWIM 프로토콜은 외부 멀티 캐스트 프리미티브를 전혀 사용하지 않습니다. 이는 실패 감지기 프로토콜에 의해 생성 된 ping, ping-req 및 ack 메시지에 전파 될 정보를 피기백함으로써 수행됩니다. 우리는 이것을 사회에서 소문이 퍼지거나 일반 인구에서 전염되는 것과 유사한 방식으로 정보가 확산됨에 따라 감염 형 전파 메커니즘이라고 부릅니다 [8]. 이 배포 구성 요소 구현은 추가 패킷(예: 멀티 캐스트)을 생성하지 않습니다. 이 구성 요소에 전달 된 모든 "메시지"는 오류 감지기의 패킷을 피기백하여 전파됩니다.

Bailey [2] presents a deterministic analysis of the spread of an epidemic within a homogeneously mixing group of n members with one initial infected member. The relation between the (expected) number of infected members x(initially 1) and time t, under a contact rate of β per time unit, is obtained as:
dx/dt = β·x·(n-x) => x = n / (1+(n-1)e^(-βnt))

Bailey [2]는 하나의 초기 감염된 구성원과 n 개의 균질 혼합 그룹 내에서 전염병의 확산에 대한 결정론적 분석을 제시합니다. 시간 단위당 β의 접촉 속도 하에서 (예상 된) 감염된 구성원 수 x(초기 1)와 시간 t 사이의 관계는 다음과 같이 얻어집니다:
dx/dt = β·x·(n-x) => x = n / (1+(n-1)e^(-βnt))

In our infection-style dissemination component, the spread of a membership update through the ping and ack messages can be analyzed in a similar manner. With the protocol period treated as a time unit, contact rate β is the probability of contact between any pair of infected and non-infected members, and equals [1-(1 - 1/n)²] = (2/n - 1/n²). This gives us x = n / (1 + (n-1)e^(-2-1/n) t). 

감염 스타일 전파기에서 ping 및 ack 메시지를 통한 멤버십 업데이트의 확산은 비슷한 방식으로 분석 될 수 있습니다. 프로토콜 기간을 시간 단위로 간주하면 접촉 빈도 β는 감염된 구성원과 비감염 된 구성원 쌍 간의 접촉 가능성입니다. 이는 [1 - (1 - 1/n)²] = (2/n - 1/n²)과 같습니다. 우리는 감염된 구성원 수 x = n / (1 + (n-1) e ^ (-2 - 1/n) t) 라는 것을 알 수 있습니다.

Such an epidemic process spreads exponentially fast in the group; after t=λ·log n rounds of the protocol, where λ is a parameter, the expected number of infected members is x = n / (1 + (n-1)n^(-2-1/n) λ) ≥ n·(1 - 1/(n^((2 - 1/n)λ-1) )). A membership update propagated in infection-style by piggybacking will thus reach (n - n^(-((2 - 1/n)λ - 2))) group members after λ·log n protocol periods. To simplify, as n increases (and → ∞), the estimate for x goes to (n - n^(-(2λ-2))). Setting λ to a small constant suffices to disseminate the epidemic reliably - this is true even at small group sizes, as borne out by our experiments in Section 5.

이러한 전염 과정은 그룹에서 기하 급수적으로 빠르게 퍼집니다. 프로토콜의 t = λ · log n 라운드 후 λ가 매개 변수 인 경우 감염된 구성원의 예상 개수는‚ x = n / (1 + (n-1) n ^ (-2-1 / n) λ입니다. ) ≥ n · (1-1 / (n ^ ((2-1 / n) λ-1))). 피기 백을 통해 감염 스타일로 전파 된 멤버쉽 업데이트는 λ · log n 프로토콜 기간 후에 (n-n ^ (-((2-1 / n) λ-2))) 그룹 구성원에 도달합니다. 간단히 말하면, n이 증가함에 따라(→ ∞) x의 추정치는 (n - n^(-(2λ-2))로 갑니다. λ를 작은 상수로 설정하면 전염병을 안정적으로 전파 할 수 있습니다. 이는 5 장의 실험에서 볼 수 있듯이 소규모 그룹에서도 마찬가지입니다.

The literature contains the analysis of several other styles of epidemics [4, 8, 13], with essentially similar conclusions about their probabilistic reliability. These analyses also show that the infection style of dissemination is resilient to process failures and loss of messages within the network, much like the contagiousness of epidemics. Experimental results of our implementation exhibit these characteristics.

문헌 [4, 8, 13] 에서는 확률론적 신뢰성에 대한 본질적으로 유사한 결론과 함께 몇 가지 다른 스타일의 감염 분석을 포함하고 있습니다. 이러한 분석은 또한 전염병의 전염성과 마찬가지로 네트워크 내의 메시지 실패와 손실을 처리하는 데 감염 스타일의 전파가 탄력적이라는 것을 보여줍니다. 구현의 실험 결과는 이러한 특성을 나타냅니다.

A word on the implementation is in order. The SWIM protocol layer at each group member Mi maintains a buffer of recent membership updates, along with a local count for each buffer element. The local count specifies the number of times the element has been piggybacked so far by Mi, and is used to choose which elements to piggyback next. Each element is piggybacked at most λ·log n times. If the size of this buffer is larger than the maximum number of elements that can be piggybacked on a single ping message (or ack), elements that have been gossiped fewer times are preferred. This is needed as the protocol period is fixed, and the rate of membership changes might temporarily overwhelm the speed of dissemination. Preferring “younger” buffer elements under such circumstances ensures that all membership changes infect at least a few members - when the membership change injection rate quiesces, these changes will propagate through the rest of the group.

구현에 관한 단어가 순서대로 있습니다. 각 그룹 멤버 Mi의 SWIM 프로토콜 계층은 각 버퍼 요소의 로컬 수와 함께 최근 멤버쉽 업데이트의 버퍼를 유지합니다. 로컬 수는 Mi가 지금까지 요소를 피기백 한 횟수를 지정하고 다음에 피기백 할 요소를 선택하는 데 사용됩니다. 각 요소는 최대 λ · log n 번 피기백됩니다. 이 버퍼의 크기가 단일 핑 메시지 (또는 ack)에서 피기 백 될 수있는 최대 요소 수보다 큰 경우, 더 적은 시간을 가졌던 요소가 선호됩니다. 이는 프로토콜 기간이 정해져 있어야하며 회원 변경 속도가 일시적으로 전파 속도를 압도 할 수 있습니다. 이러한 상황에서 "더 어린" 버퍼 요소를 선호하면 모든 멤버십 변경이 최소한 소수의 멤버에 영향을 미치게됩니다. 멤버십 변경 주입 비율이 정지되면 이러한 변경 사항이 그룹의 나머지 부분을 통해 전파됩니다.

Our implementation of this protocol maintains two lists of group members - a list of members that are not yet declared as failed in the group, and a second list of members that have failed recently. Currently, an equal number of buffer of elements is chosen from these two lists for piggybacking, but the scheme could be generalized to adapt to relative variations in process join, leave and failure rates.

이 프로토콜 구현은 두 개의 그룹 구성원 목록(그룹에서 아직 실패로 선언되지 않은 구성원 목록과 최근에 실패한 구성원 목록)이 유지됩니다. 현재 피기백을 위해이 두 목록에서 동일한 수의 요소 버퍼를 선택하지만 프로세스 참여, 탈퇴 및 실패율의 상대적인 변동에 맞게 체계를 일반화 할 수 있습니다.


### 4.2. Suspicion Mechanism: Reducing the Frequency of False Positives

### 4.2. 의심 메커니즘: 오 탐지 빈도 감소

In the SWIM failure detector protocol described so far, if a non-faulty group member Mj is (mistakenly) detected as failed by another group member Mi, either due to network packet losses or because Mj was asleep for some time, or because Mi is a slow process, then Mj will be declared as failed in the group. In other words, a perfectly healthy process Mj suffers a very heavy penalty, by being forced to drop out of the group at the very first instance that it is mistakenly detected as failed in the group. This leads to a high rate of false positives in detecting failures.

지금까지 설명한 SWIM 장애 탐지기 프로토콜에서, 결함이없는 그룹 멤버 Mj가 네트워크 패킷 손실 또는 Mj가 일정 시간 동안 잠 들어 있거나 Mi가 느린 프로세스 인 경우 등의 이유로 Mi 가 잘못 감지하게되면 Mj는 그룹에서 실패한 것으로 선언됩니다. 다시 말해, 완벽하게 건전한 프로세스 Mj는 그룹에서 실패한 것으로 잘못 감지한 첫 번째 인스턴스에 의해 그룹에서 제거됨으로써 매우 큰 페널티를받습니다. 이로 인해 실패를 탐지 할 때 높은 오 탐률이 발생합니다.

We reduce the effect of this problem by modifying SWIM to run a subprotocol, called the Suspicion subprotocol, whenever a failure is detected by the basic SWIM failure detector protocol.

기본 SWIM 장애 탐지기 프로토콜에 의해 장애가 감지 될 때마다 Suspicion 하위 프로토콜이라고하는 하위 프로토콜을 실행하도록 SWIM을 수정하여 이 문제의 영향을 줄입니다.

The Suspicion subprotocol works as follows. Consider a member Mi that chooses a member Mj as a ping target in the current protocol period, and runs the basic SWIM failure detector protocol period. If Mi receives no acknowledgments, either directly or through the indirect probing subgroup, it does not declare Mj as failed. Instead, Mi marks Mj as a Suspected member in the local membership list at Mi. In addition, a {Suspect Mj: Mi suspects Mj} message is disseminated through the group through the Dissemination Component (in infection-style in our system). Any group member Ml receiving such a message also marks Mj as suspected. Suspected members stay on in the membership list and are treated similar to non-faulty members with regards to ping target selection operation of the SWIM failure detector protocol.

의심 하위 프로토콜은 다음과 같이 작동합니다. 현재 프로토콜 기간에서 멤버 Mj를 핑 대상으로 선택하고 기본 SWIM 장애 감지기 프로토콜 기간을 실행하는 구성원 Mi를 생각해보겠습니다. Mi가 직접 또는 간접 프로빙 하위 그룹을 통해 승인을 받지 못하면 Mj가 실패한 것으로 선언하지 않습니다. 대신 Mi는 Mi의 로컬 멤버십 목록에서 Mj를 의심되는 멤버로 표시합니다. 또한 {Suspect Mj : Mi suspects Mj} 메시지는 시스템에서 감염 스타일로 배포 구성 요소를 통해 그룹을 통해 배포됩니다. 이러한 메시지를 받는 모든 그룹 구성원 Ml도 Mj를 의심으로 표시합니다. 의심되는 멤버는 멤버십 목록에 남아 있으며 SWIM 장애 감지기 프로토콜의 ping 대상 선택 작업과 관련하여 결함이 없는 멤버와 유사하게 취급됩니다.

If a member Ml successfully pings a suspected member Mj during the due course of the basic SWIM protocol, it un-marks the previous suspicion of Mj in its membership list, and spreads an {Alive Mj: Ml knows Mj is alive} message in the group through the Dissemination Component (in infection-style in our system). Such an Alive message un-marks the suspected member Mj in membership lists of recipient members. Notice that if member Mj receives such a message suspecting it, it can start propagating an Alive message clarifying its non-failure.

멤버 Ml이 기본 SWIM 프로토콜 절차에 따라 의심되는 멤버 Mj를 ping하는 데 성공한 경우 멤버리스트에서 Mj에 대하여 이전의 의심 표시를 해제하고 {Alive Mj: Ml knows Mj is alive} 메시지를 전파기를 통해 (감염 스타일로) 전파합니다. 이러한 Alive 메시지는 수신자 멤버의 멤버십 목록에서 의심되는 멤버 Mj의 표시를 해제합니다. 멤버 Mj가 자신을 의심하는 이런 메시지를 수신한다면, 자신의 건재함을 알리는 Alive 메시지 전파을 시작할 수 있음에 주목하십시오.

Suspected entries in membership lists expire after a prespecified time-out. If Mj is suspected at some member Mh, and this entry times-out before receipt of an Alive message, Mh declares Mj as faulty, drops it from the local membership list, and begins spreading the message {Confirm Mj: Mh declares Mj as faulty} through the Dissemination Component. This message overrides any previous Suspect or Alive messages, and cascades in the deletion of Mj from the membership lists of all recipients.

멤버십 목록에서 의심되는 항목은 사전 지정된 시간 초과 후에 만료됩니다. 일부 회원 Mh에서 Mj가 의심되고 Alive 메시지를 수신하기 전에 이 항목이 시간 초과 된 경우 Mh는 Mj를 결함으로 선언하고 로컬 회원 목록에서 삭제 한 후 {Confirm Mj: Mh declares Mj as faulty} 메시지를 전파기를 통해 배포하기 시작합니다. 이 메시지는 이전의 모든 Suspect 또는 Alive 메시지를 무시하고 모든 수신자의 멤버십 목록에서 Mj를 삭제하는 단계에 해당합니다.

This mechanism reduces (but does not eliminate) the rate of failure detection false positives. Notice also that the Strong Completeness property of the original protocol continues to hold. Failures of processes suspecting a failed process Mj may prolong detection time, but eventual detection is guaranteed.

이 메커니즘은 오탐율을 줄이지만 제거하지는 않습니다. 원래 프로토콜의 강한 완벽성 Strong Completeness 속성은 계속 유지됩니다. 의심되던 프로세스 Mj가 결국은 실패한 것으로 확인이 되었을 때 프로세스 실패 감지 시간은 늦춰질 수 있지만 결과적으로 감지는 보장됩니다.

From the above discussion, Alive messages override Suspect messages, and Confirm messages override both Suspect and Alive messages, in their effect on the local membership list element corresponding to the suspected member Mj. However, a member might be suspected and unsuspected multiple times during its lifetime. These multiple versions of Suspect and Alive messages (all pertaining to the same member Mj) need to be distinguished through unique identifiers. These identifiers are provided by using a virtual incarnation number field with each element in the membership lists. Incarnation numbers are global. A member Mi’s incarnation number is initialized to 0 when it joins the group, and it can be incremented only by Mi, when it receives information (through the Dissemination Component) about itself being suspected in the current incarnation - Mi then generates an Alive message with its identifier and an incremented incarnation number, and spreads this through the Dissemination Component to the group.

위의 설명에서 Alive 메시지는 의심 메시지를 오버라이드하고, Confirm 메시지는 의심되는 멤버 Mj에 해당하는 로컬 멤버십 목록에 영향을 미치므로 Suspect와 Alive 메시지 모두를 오버라이드합니다. 그러나 멤버는 일생 동안 여러 번 의심되고 의심되지 않을 수 있습니다. 이러한 여러 버전의 Suspect 및 Alive 메시지 (모두 동일한 멤버 Mj와 관련된)는 고유 식별자를 통해 구별해야합니다. 이러한 식별자는 멤버십 목록의 각 요소와 함께 가상 구체화 번호 필드를 사용하여 제공됩니다. 구체화 번호는 광역적입니다. 멤버 Mi의 구체화 번호는 그룹에 가입 할 때 0으로 초기화되며, 의심된다는 자신에 대한 정보를 (전파기를 통해) 수신하면 Mi 만이 현재 구체화 번호를 증가 시킬 수 있습니다. 그런다음 Mi는 식별자와 증가된 구체화 번호와 함께 Alive 메시지를 생성하고, 이것을 전파기를 통해 그룹으로 전파합니다.

Thus, Suspect, Alive, and Confirm messages contain the incarnation number of the member, besides its identifier. The order of preference among these messages and their effect on the membership list is specified below.

따라서 Suspect, Alive 및 Confirm 메시지에는 식별자 외에 멤버의 구체화 번호가 포함됩니다. 이러한 메시지 중 우선 순위와 멤버십 목록에 대한 영향은 다음과 같습니다.

• {Alive Ml, inc = i} overrides

   – {Suspect Ml, inc = j}, i > j

   – {Alive Ml, inc = j}, i > j

• {Suspect Ml, inc = i} overrides

   – {Suspect Ml, inc = j}, i ≥ j

   – {Alive Ml, inc = j}, i ≥ j

• {Confirm Ml, inc = i} overrides

   – {Alive Ml, inc = j}, any j

   – {Suspect Ml, inc = j}, any j

It is easy to see that these orders of preference and overriding maintain the desired correctness properties of the Failure Detector Component. The reader familiar with adhoc routing protocols such as AODV [5] will notice the similarity between their use of destination sequence numbers and our incarnation number scheme.

이러한 우선 순위 및 재정의 순서는 장애 감지기의 원하는 정확성 속성을 유지한다는 것을 쉽게 알 수 있습니다. AODV [5]와 같은 adhoc 라우팅 프로토콜에 익숙한 독자는 대상 시퀀스 번호 사용과 구체화 번호 체계 사이의 유사성을 알 수 있습니다.

The preference rules and infection-style Dissemination Component also accommodate suspicions of a process by multiple other processes. Preference rules do not depend on the source of suspicion, and the infection-style dissemination spreads a message (Suspect, Alive or Confirm) quicker if there are multiple sources, with exactly the same overhead per process as with one source of infection [8].

선호 규칙 및 감염 스타일 전파기는 여러 다른 프로세스에 의한 프로세스의 의심을 수용합니다. 선호 규칙은 의심의 근원에 의존하지 않으며, 감염 스타일의 보급은 여러 출처가 있는 경우에도 감염 근원이 하나인 경우와 정확히 동일한 오버 헤드를 갖는 메시지 (Suspect, Alive 또는 Confirm)를 더 빨리 전파합니다 [8] .


### 4.3. Round-Robin Probe Target Selection: Providing Time-Bounded Strong Completeness

### 4.3. 라운드 로빈 프로브 대상 선택: 시간에 따른 강력한 완성도 제공

The basic SWIM failure detector protocol described in Section 3 detects failures in an average constant number of protocol periods. Although each process failure is guaranteed to be detected eventually at every other non-faulty process (eventual Strong Completeness), a pathological selection of ping targets across the group might lead to a large delay in the first detection of the process failure anywhere in the group. In the extreme case, this delay could be unbounded as the failed process might never be chosen as a ping target by any other non-faulty process

3장에 설명된 기본 SWIM 장애 탐지기 프로토콜은 평균 일정한 수의 프로토콜주기에서 장애를 탐지합니다. 각 프로세스 실패가 다른 모든 결함이없는 프로세스에서 발견 될 수는 있지만(궁극적인 강한 완벽성),그룹 전체의 핑 대상을 병리학적으로 선택하면 그룹 내 어디에서나 프로세스 실패를 처음 감지하는 데 큰 지연이 발생할 수 있습니다. 극단적 인 경우, 결함이 있는 프로세스가 결함이 없는 다른 프로세스에 의해 핑 대상으로 선택 될 수 없으므로 이 지연은 제한이 없습니다.

This can be solved by the following modification to the protocol. The failure detection protocol at member Mi works by maintaining a list (intuitively, an array) of the known elements of the current membership list, and selecting ping targets not randomly from this list, but in a round-robin fashion. Instead, a newly joining member is inserted in the membership list at a position that is chosen uniformly at random. On completing a traversal of the entire list, Mi rearranges the membership list to a random reordering.

이는 프로토콜을 다음과 같이 수정하여 해결할 수 있습니다. 멤버 Mi의 실패 감지 프로토콜은 현재 멤버쉽 목록의 알려진 요소 목록 (직관적으로 배열)을 유지 관리하고 이 목록에서 임의로 핑 대상을 선택하지 않고 라운드 로빈 방식으로 작동합니다. 대신, 새로 가입 한 멤버가 무작위로 균일하게 선택된 위치에서 멤버십 목록에 삽입됩니다. 전체 목록의 순회를 완료하면 Mi는 멤버십 목록을 무작위로 재정렬합니다.

Consider the execution of the SWIM protocol, modified as described above, at member Mi. Once another member Mj is included in Mi’s membership list, it will be chosen as a ping target exactly once during each traversal of Mi’s membership list. If the size of the membership list is no more than ni, successive selections of the same target are at most (2 · ni - 1) protocol periods apart. This bounds the worst case detection time of a process failure of any member by Mi, thus satisfying a Time Bounded Completeness property.

멤버 Mi에서 위에서 설명한대로 수정 된 SWIM 프로토콜의 실행을 고려하십시오. 다른 회원 Mj가 Mi의 회원 목록에 포함되면 Mi의 회원 목록을 순행 할 때마다 정확히 한 번 핑 대상으로 선택됩니다. 멤버십 목록의 크기가 ni를 넘지 않는 경우 동일한 대상을 연속적으로 선택하는 프로토콜 기간이 최대 (2 · ni - 1)입니다. 이는 Mi에 의한 멤버의 프로세스 실패에 대한 최악의 감지 시간을 제한하므로 Time Bounded Completeness 특성을 만족시킵니다.

The average failure detection time of the original protocol is preserved by this optimization, since the randomization of the membership lists at different members across the group leads to a similar distribution of ping target choices by each member.

그룹 전체의 다른 멤버에있는 멤버십 목록을 랜덤화하면 각 멤버별로 유사한 핑 대상 선택이 분배되므로 원래 프로토콜의 평균 실패 감지 시간이 이 최적화에 의해 보장됩니다.
